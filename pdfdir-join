#!/bin/bash
#
# pdfdir-join     http://github.com/bronson/pdfdir
# Scott Bronson
# 17 Mar 2009
#
# This script assembles a bunch of PDFs files into a single pdf with
# bookmarks to each file.
#
# Your files should be arranged in a hierarchy, somewhat like this:
#     book/01-Introduction.pdf
#     book/02-Engine
#     book/02-Engine/01-Oil.pdf
#     book/02-Engine/01-Freeze Plugs.pdf
# The "01-", "02-" only force the ordering of the files.  Everything before the
# first dash will be stripped from the bookmark name.
#
# Then just run the script:
#     $ pdfdir-join book
#
# TODO: it would not be too hard to preserve existing bookmarks.  Just need
# to read them, offset them, and include them in the new bookmark file.


die () {
	echo "$*" >&2
	[ -n "$streamfile" ] && rm -f "$streamfile"
	exit 1
}

root="${1%/}"
[ -z "$root" ] && die "Please specify a directory to operate on"
outbase="$(basename "$root")"
[ "x$outbase" = "x." ] && outbase=out
[ -f "$outbase".pdf ] && die "Will not overwrite $outbase.pdf"


# Turns the output from ghostscript into a bookmark file.
process_gs_output() {
	pat_filename='--- PDFDIR FILE: (.*)$'
	pat_newfile='Processing pages ([0-9]+) through ([0-9]+)'
	pat_newpage='Page ([0-9]+)'
	outpage=1
	corrupt=start

	while read line; do
		if [[ $line =~ $pat_filename ]]; then
			[ "$corrupt" = "yes" ] && echo -n " CORRUPT!"
			corrupt=yes
			curpath="${BASH_REMATCH[1]}"
			curpathno=$((curpathno + 1))
			[ -z "$curpath" ] && die "Wasn't told filename?"
			echo -e "\nFile $curpathno/$pathcount: $curpath"
		elif [[ $line =~ $pat_newfile ]]; then
			# check to see if ghostscript has lost its mind
			[ "x$totalpages" != "x$inpage" ] && die "Did not match: $inpage vs $totalpages"
			outpage=$((outpage + inpage))
			inpage=1
			totalpages="${BASH_REMATCH[2]}"
			echo "$outpage ${curpath#$root/}" >&6
			echo -n " $totalpages Page$([ "$totalpages" -eq 1 ] || echo -n s):"
		elif [[ $line =~ $pat_newpage ]]; then
			inpage="${BASH_REMATCH[1]}"
			echo -n " $((inpage+outpage-1))"
			corrupt=no
		fi
	done
	echo
	exec 6>&-
}


format_markfile() {
	while read count page title; do
		[ "$count" -eq 0 ] && count='' || count="/Count $count "
		title="$(echo "$title" | sed -e 's/\([()\\\]\)/\\\1/g')" # escape PDF string
		echo "[ $count/Title ($title) /Page $page /OUT pdfmark"
	done
}


# ok lets go

pathfile="$outbase".paths
pathcount="$(find "$root" -name "*.pdf" -print | sort | tee "$pathfile" | wc -l | tr -d ' ')"
streamfile="$outbase".stream
exec 6>"$streamfile"

while read path; do
  escpath="$(echo "$path" | sed -e 's/\([()\]\)/\\\1/g')"
  echo "($escpath) dup (--- PDFDIR FILE: ) exch concatstrings = run"
done < "$pathfile" | ghostscript -sDEVICE=pdfwrite -sOUTPUTFILE="$outbase".nomarks.pdf -dNOPAUSE | process_gs_output

if [ -f "$streamfile" ]; then
	echo "Applying bookmarks..."
	cat "$streamfile" | ./pdfdir-tokenize | ./pdfdir-makemarks | format_markfile > "$outbase".marks
	ghostscript -dBATCH -dNOPAUSE -sDEVICE=pdfwrite -sOutputFile="$outbase".pdf "$outbase".nomarks.pdf "$outbase".marks
	rm "$streamfile" "$outbase".marks
	echo "PDF saved to $outbase".pdf
	echo
fi

rm "$pathfile"
rm -f "$outbase".nomarks.pdf

